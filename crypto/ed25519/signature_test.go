package ed25519

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"io/ioutil"
	"testing"
)

var (
	// Signatures in this test are generated by the private/public keypair
	// from the 'keys_test.go' file
	sigEd = []byte{
		0x26, 0x24, 0x83, 0xe7, 0x85, 0x51, 0x4f, 0x12,
		0x28, 0x16, 0xf5, 0xd0, 0xd8, 0x99, 0xcd, 0x05,
		0x4e, 0x24, 0xe0, 0x19, 0xb1, 0x0e, 0x4c, 0xd5,
		0x41, 0x3e, 0xb8, 0xc3, 0xe3, 0xaf, 0x50, 0x64,

		0x34, 0xb7, 0x89, 0xab, 0x30, 0x27, 0x27, 0xe9,
		0x17, 0xfd, 0xf3, 0x0e, 0x2c, 0xc1, 0xbd, 0xaf,
		0xb4, 0xb2, 0x47, 0x58, 0xe9, 0x4b, 0x77, 0xd2,
		0xb1, 0x4a, 0xcf, 0xf7, 0x59, 0x13, 0x27, 0x0f,
	}

	msgEd = []byte{
		0x00, 0x00, 0x00, 0x22,
		0x00, 0x00, 0x00, 0x01,
		0x00, 0x05, 0x70, 0xad, 0xe2, 0x8b, 0x6b, 0xa5,
		0x00, 0x00, 0x00, 0x0e,
		0x74, 0x63, 0x70, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0xac, 0x11, 0x00, 0x05,
		0x08, 0x26,
	}

	sigEc = []byte{
		0x07, 0x7b, 0x81, 0xf9, 0xfc, 0x96, 0xa9, 0x64,
		0x0f, 0x44, 0xb0, 0xbe, 0x29, 0xea, 0xbd, 0x5e,
		0x8d, 0xde, 0xa5, 0x93, 0x78, 0xa8, 0x78, 0x73,
		0x0b, 0x69, 0xc6, 0x8c, 0x5f, 0x74, 0xc6, 0xd5,

		0x0e, 0xd0, 0x42, 0xa8, 0x48, 0xaa, 0x63, 0xc1,
		0x4f, 0xc7, 0xfb, 0x10, 0x1a, 0x54, 0x75, 0x36,
		0x15, 0x0b, 0x75, 0xcb, 0xee, 0x1a, 0xcb, 0x7a,
		0x70, 0xf6, 0x26, 0x61, 0xf1, 0xc4, 0x8f, 0x33,
	}

	msgEc = []byte{
		0x49, 0x20, 0x83, 0x5b, 0x92, 0xb4, 0x7d, 0x14,
		0x4e, 0x88, 0x96, 0x48, 0xa5, 0xba, 0x53, 0x39,
		0x42, 0xa7, 0x85, 0xb0, 0x66, 0x91, 0x43, 0x3f,
		0x2c, 0x59, 0x85, 0x0d, 0x9f, 0x3e, 0xb0, 0x08,
	}
)

func TestEdDSA(t *testing.T) {
	sigT, err := prv.EdSign(msgEd)
	if err != nil {
		t.Fatal(err)
	}
	sigX := sigT.Bytes()

	// signature is deterministic, so we can check the computed signature
	if bytes.Compare(sigX, sigEd) != 0 {
		t.Logf("SIG(computed): %s\n", hex.EncodeToString(sigX))
		t.Logf("SIG(expected): %s\n", hex.EncodeToString(sigEd))
		t.Fatal("Signature mismatch")
	}
	rc, err := pub.EdVerify(msgEd, sigT)
	if err != nil {
		t.Fatal(err)
	}
	if !rc {
		t.Fatal("Verify failed")
	}

	// test failure
	sigX[23] ^= 0x56
	sigT2, err := NewEdSignatureFromBytes(sigX)
	if err != nil {
		t.Fatal(err)
	}
	if rc, err = pub.EdVerify(msgEd, sigT2); err != nil {
		t.Fatal(err)
	}
	if rc {
		t.Fatal("Verify succeeded on bad signature")
	}
}

func TestEcDSA(t *testing.T) {
	// test simple sign/verify
	sigT, err := prv.EcSign(msgEc)
	if err != nil {
		t.Fatal(err)
	}
	rc, err := pub.EcVerify(msgEc, sigT)
	if err != nil {
		t.Fatal(err)
	}
	if !rc {
		t.Fatal("Verify failed (1)")
	}

	// test if signatures are deterministic
	sigU, err := prv.EcSign(msgEc)
	if err != nil {
		t.Fatal(err)
	}
	if bytes.Compare(sigT.Bytes(), sigU.Bytes()) != 0 {
		t.Fatal("Signatures not deterministic")
	}

	// test serialization
	sigData := sigT.Bytes()
	sigT, err = NewEcSignatureFromBytes(sigData)
	if err != nil {
		t.Fatal(err)
	}
	if bytes.Compare(sigData, sigT.Bytes()) != 0 {
		t.Fatal("Signature serialization failed")
	}

	// test pre-set signature
	sigT, err = NewEcSignatureFromBytes(sigEc)
	if err != nil {
		t.Fatal(err)
	}
	rc, err = pub.EcVerify(msgEc, sigT)
	if err != nil {
		t.Fatal(err)
	}
	if !rc {
		t.Fatal("Verify failed (2)")
	}

	// test failure.
	sigData[23] ^= 0xA5
	sigT, err = NewEcSignatureFromBytes(sigData)
	if err != nil {
		t.Fatal(err)
	}
	rc, err = pub.EcVerify(msgEc, sigT)
	if err != nil {
		t.Fatal(err)
	}
	if rc {
		t.Fatal("Verify succeeded on bad signature")
	}
}

type eddsaTestData struct {
	Pk string `json:"prv"`
	S  string `json:"sig"`
	M  string `json:"msg"`
}

func TestEdDSAVector(t *testing.T) {

	if testing.Short() {
		return
	}

	tests := make([]*eddsaTestData, 0)
	data, err := ioutil.ReadFile("./signature_test.json")
	if err != nil {
		t.Fatal(err)
	}
	if err = json.Unmarshal(data, &tests); err != nil {
		t.Fatal(err)
	}

	hex2bin := func(s string) []byte {
		buf, err := hex.DecodeString(s)
		if err != nil {
			t.Fatal(err)
		}
		return buf
	}
	for i, test := range tests {
		prv := NewPrivateKeyFromSeed(hex2bin(test.Pk[:64]))
		pub := prv.Public()
		if bytes.Compare(hex2bin(test.Pk[64:]), pub.Bytes()) != 0 {
			t.Logf("pub(expected): %s\n", test.Pk[64:])
			t.Logf("pub(computed): %s\n", hex.EncodeToString(pub.Bytes()))
			t.Fatal("public key mismatch")
		}

		m := hex2bin(test.M)

		s, err := NewEdSignatureFromBytes(hex2bin(test.S))
		if err != nil {
			t.Fatal(err)
		}
		ss := hex.EncodeToString(s.Bytes())
		if ss != test.S {
			t.Logf("ss(expected): %s\n", test.S)
			t.Logf("ss(computed): %s\n", ss)
			t.Fatal("Sig serialization failed")
		}

		sig, err := prv.EdSign(m)
		if err != nil {
			t.Fatal(err)
		}
		if !sig.R.Equals(s.R) {
			t.Logf("R(expected): %v\n", hex.EncodeToString(s.R.Bytes()))
			t.Logf("R(computed): %v\n", hex.EncodeToString(sig.R.Bytes()))
			t.Fatalf("signatures don't match (R) at %d", i)
		}
		if sig.S.Cmp(s.S) != 0 {
			t.Logf("S(expected): %v\n", hex.EncodeToString(s.S.Bytes()))
			t.Logf("S(computed): %v\n", hex.EncodeToString(sig.S.Bytes()))
			t.Fatalf("signatures don't match (S) at %d", i)
		}
		var rc bool
		rc, err = pub.EdVerify(m, sig)
		if err != nil {
			t.Fatal(err)
		}
		if !rc {
			t.Fatal("Verify failed")
		}
	}
}
