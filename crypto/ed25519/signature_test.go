package ed25519

//----------------------------------------------------------------------
// This file is part of Gospel.
// Copyright (C) 2011-present, Bernd Fix  >Y<
//
// Gospel is free software: you can redistribute it and/or modify it
// under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// Gospel is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// SPDX-License-Identifier: AGPL3.0-or-later
//----------------------------------------------------------------------

import (
	"bytes"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/hex"
	"encoding/json"
	"hash"
	"os"
	"testing"

	"github.com/bfix/gospel/math"
)

var (
	// Signatures in this test are generated by the private/public keypair
	// from the 'keys_test.go' file
	sigEd = []byte{
		0x26, 0x24, 0x83, 0xe7, 0x85, 0x51, 0x4f, 0x12,
		0x28, 0x16, 0xf5, 0xd0, 0xd8, 0x99, 0xcd, 0x05,
		0x4e, 0x24, 0xe0, 0x19, 0xb1, 0x0e, 0x4c, 0xd5,
		0x41, 0x3e, 0xb8, 0xc3, 0xe3, 0xaf, 0x50, 0x64,

		0x34, 0xb7, 0x89, 0xab, 0x30, 0x27, 0x27, 0xe9,
		0x17, 0xfd, 0xf3, 0x0e, 0x2c, 0xc1, 0xbd, 0xaf,
		0xb4, 0xb2, 0x47, 0x58, 0xe9, 0x4b, 0x77, 0xd2,
		0xb1, 0x4a, 0xcf, 0xf7, 0x59, 0x13, 0x27, 0x0f,
	}

	msgEd = []byte{
		0x00, 0x00, 0x00, 0x22,
		0x00, 0x00, 0x00, 0x01,
		0x00, 0x05, 0x70, 0xad, 0xe2, 0x8b, 0x6b, 0xa5,
		0x00, 0x00, 0x00, 0x0e,
		0x74, 0x63, 0x70, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0xac, 0x11, 0x00, 0x05,
		0x08, 0x26,
	}

	sigEc = []byte{
		0x07, 0x7b, 0x81, 0xf9, 0xfc, 0x96, 0xa9, 0x64,
		0x0f, 0x44, 0xb0, 0xbe, 0x29, 0xea, 0xbd, 0x5e,
		0x8d, 0xde, 0xa5, 0x93, 0x78, 0xa8, 0x78, 0x73,
		0x0b, 0x69, 0xc6, 0x8c, 0x5f, 0x74, 0xc6, 0xd5,

		0x0e, 0xd0, 0x42, 0xa8, 0x48, 0xaa, 0x63, 0xc1,
		0x4f, 0xc7, 0xfb, 0x10, 0x1a, 0x54, 0x75, 0x36,
		0x15, 0x0b, 0x75, 0xcb, 0xee, 0x1a, 0xcb, 0x7a,
		0x70, 0xf6, 0x26, 0x61, 0xf1, 0xc4, 0x8f, 0x33,
	}

	msgEc = []byte{
		0x49, 0x20, 0x83, 0x5b, 0x92, 0xb4, 0x7d, 0x14,
		0x4e, 0x88, 0x96, 0x48, 0xa5, 0xba, 0x53, 0x39,
		0x42, 0xa7, 0x85, 0xb0, 0x66, 0x91, 0x43, 0x3f,
		0x2c, 0x59, 0x85, 0x0d, 0x9f, 0x3e, 0xb0, 0x08,
	}
)

func TestEdDSA(t *testing.T) {
	sigT, err := prv.EdSign(msgEd)
	if err != nil {
		t.Fatal(err)
	}
	sigX := sigT.Bytes()

	// signature is deterministic, so we can check the computed signature
	if !bytes.Equal(sigX, sigEd) {
		t.Logf("SIG(computed): %s\n", hex.EncodeToString(sigX))
		t.Logf("SIG(expected): %s\n", hex.EncodeToString(sigEd))
		t.Fatal("Signature mismatch")
	}
	rc, err := pub.EdVerify(msgEd, sigT)
	if err != nil {
		t.Fatal(err)
	}
	if !rc {
		t.Fatal("Verify failed")
	}

	// test failure
	sigX[23] ^= 0x56
	sigT2, err := NewEdSignatureFromBytes(sigX)
	if err != nil {
		t.Fatal(err)
	}
	if rc, err = pub.EdVerify(msgEd, sigT2); err != nil {
		t.Fatal(err)
	}
	if rc {
		t.Fatal("Verify succeeded on bad signature")
	}
}

func TestEcDSA(t *testing.T) {
	// test simple sign/verify
	sigT, err := prv.EcSign(msgEc)
	if err != nil {
		t.Fatal(err)
	}
	rc, err := pub.EcVerify(msgEc, sigT)
	if err != nil {
		t.Fatal(err)
	}
	if !rc {
		t.Fatal("Verify failed (1)")
	}

	// test if signatures are deterministic
	sigU, err := prv.EcSign(msgEc)
	if err != nil {
		t.Fatal(err)
	}
	if !bytes.Equal(sigT.Bytes(), sigU.Bytes()) {
		t.Fatal("Signatures not deterministic")
	}

	// test serialization
	sigData := sigT.Bytes()
	sigT, err = NewEcSignatureFromBytes(sigData)
	if err != nil {
		t.Fatal(err)
	}
	if !bytes.Equal(sigData, sigT.Bytes()) {
		t.Fatal("Signature serialization failed")
	}

	// test pre-set signature
	sigT, err = NewEcSignatureFromBytes(sigEc)
	if err != nil {
		t.Fatal(err)
	}
	rc, err = pub.EcVerify(msgEc, sigT)
	if err != nil {
		t.Fatal(err)
	}
	if !rc {
		t.Fatal("Verify failed (2)")
	}

	// test failure.
	sigData[23] ^= 0xA5
	sigT, err = NewEcSignatureFromBytes(sigData)
	if err != nil {
		t.Fatal(err)
	}
	rc, err = pub.EcVerify(msgEc, sigT)
	if err != nil {
		t.Fatal(err)
	}
	if rc {
		t.Fatal("Verify succeeded on bad signature")
	}
}

func TestKDetEcDSA(t *testing.T) {
	type tc struct {
		hsh func() hash.Hash
		msg string
		k   string
	}

	// RFC 6979, A.2.5. ECDSA, 256 Bits (Prime Field)
	var (
		x = []byte{
			0xC9, 0xAF, 0xA9, 0xD8, 0x45, 0xBA, 0x75, 0x16, 0x6B, 0x5C, 0x21, 0x57, 0x67, 0xB1, 0xD6, 0x93,
			0x4E, 0x50, 0xC3, 0xDB, 0x36, 0xE8, 0x9B, 0x12, 0x7B, 0x8A, 0x62, 0x2B, 0x12, 0x0F, 0x67, 0x21,
		}
		n = []byte{
			0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xBC, 0xE6, 0xFA, 0xAD, 0xA7, 0x17, 0x9E, 0x84, 0xF3, 0xB9, 0xCA, 0xC2, 0xFC, 0x63, 0x25, 0x51,
		}
		c = []*tc{
			//{sha1.New, "sample", "882905F1227FD620FBF2ABF21244F0BA83D0DC3A9103DBBEE43A1FB858109DB4"},
			{sha256.New224, "sample", "103F90EE9DC52E5E7FB5132B7033C63066D194321491862059967C715985D473"},
			{sha256.New, "sample", "A6E3C57DD01ABE90086538398355DD4C3B17AA873382B0F24D6129493D8AAD60"},
			{sha512.New384, "sample", "09F634B188CEFD98E7EC88B1AA9852D734D0BC272F7D2A47DECC6EBEB375AAD4"},
			{sha512.New, "sample", "5FA81C63109BADB88C1F367B47DA606DA28CAD69AA22C4FE6AD7DF73A7173AA5"},
			//{sha1.New, "test", "8C9520267C55D6B980DF741E56B4ADEE114D84FBFA2E62137954164028632A2E"},
			{sha256.New224, "test", "669F4426F2688B8BE0DB3A6BD1989BDAEFFF84B649EEB84F3DD26080F667FAA7"},
			{sha256.New, "test", "D16B6AE827F17175E040871A1C7EC3500192C4C92677336EC2537ACAEE0008E0"},
			{sha512.New384, "test", "16AEFFA357260B04B1DD199693960740066C1A8F3E8EDD79070AA914D361B3B8"},
			{sha512.New, "test", "6915D11632ACA3C40D5D51C08DAF9C555933819548784480E93499000D9F0B7F"},
		}
	)
	sk := math.NewIntFromBytes(x)
	ni := math.NewIntFromBytes(n)

	for _, ce := range c {

		hsh := ce.hsh()
		hsh.Write([]byte(ce.msg))
		hv := hsh.Sum(nil)

		gen, err := newKGenerator(true, sk, ni, len(x), hv, ce.hsh)
		if err != nil {
			t.Fatal(err)
		}
		ki, err := gen.next()
		if err != nil {
			t.Fatal(err)
		}
		k, err := hex.DecodeString(ce.k)
		if err != nil {
			t.Fatal(err)
		}
		if !bytes.Equal(k, ki.Bytes()) {
			t.Logf("k = %s\n", hex.EncodeToString(k))
			t.Logf(" != %s\n", hex.EncodeToString(ki.Bytes()))
			t.Fatal("detECDSA: bad 'k'")
		}
	}
}

type eddsaTestData struct {
	Pk string `json:"prv"`
	S  string `json:"sig"`
	M  string `json:"msg"`
}

func TestEdDSAVector(t *testing.T) {

	if testing.Short() {
		return
	}

	tests := make([]*eddsaTestData, 0)
	data, err := os.ReadFile("./signature_test.json")
	if err != nil {
		t.Fatal(err)
	}
	if err = json.Unmarshal(data, &tests); err != nil {
		t.Fatal(err)
	}

	hex2bin := func(s string) []byte {
		buf, err := hex.DecodeString(s)
		if err != nil {
			t.Fatal(err)
		}
		return buf
	}
	for i, test := range tests {
		prv := NewPrivateKeyFromSeed(hex2bin(test.Pk[:64]))
		pub := prv.Public()
		if !bytes.Equal(hex2bin(test.Pk[64:]), pub.Bytes()) {
			t.Logf("pub(expected): %s\n", test.Pk[64:])
			t.Logf("pub(computed): %s\n", hex.EncodeToString(pub.Bytes()))
			t.Fatal("public key mismatch")
		}

		m := hex2bin(test.M)

		s, err := NewEdSignatureFromBytes(hex2bin(test.S))
		if err != nil {
			t.Fatal(err)
		}
		ss := hex.EncodeToString(s.Bytes())
		if ss != test.S {
			t.Logf("ss(expected): %s\n", test.S)
			t.Logf("ss(computed): %s\n", ss)
			t.Fatal("Sig serialization failed")
		}

		sig, err := prv.EdSign(m)
		if err != nil {
			t.Fatal(err)
		}
		if !sig.R.Equals(s.R) {
			t.Logf("R(expected): %v\n", hex.EncodeToString(s.R.Bytes()))
			t.Logf("R(computed): %v\n", hex.EncodeToString(sig.R.Bytes()))
			t.Fatalf("signatures don't match (R) at %d", i)
		}
		if sig.S.Cmp(s.S) != 0 {
			t.Logf("S(expected): %v\n", hex.EncodeToString(s.S.Bytes()))
			t.Logf("S(computed): %v\n", hex.EncodeToString(sig.S.Bytes()))
			t.Fatalf("signatures don't match (S) at %d", i)
		}
		var rc bool
		rc, err = pub.EdVerify(m, sig)
		if err != nil {
			t.Fatal(err)
		}
		if !rc {
			t.Fatal("Verify failed")
		}
	}
}
