package ed25519

//----------------------------------------------------------------------
// This file is part of Gospel.
// Copyright (C) 2011-2020 Bernd Fix
//
// Gospel is free software: you can redistribute it and/or modify it
// under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// Gospel is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// SPDX-License-Identifier: AGPL3.0-or-later
//----------------------------------------------------------------------

import (
	"crypto/rand"
	"crypto/sha512"

	"github.com/bfix/gospel/math"
)

//----------------------------------------------------------------------
// Public key
//----------------------------------------------------------------------

// PublicKey is a point on the Ed25519 curve.
type PublicKey struct {
	Q *Point
}

// NewPublicKeyFromBytes creates a new public key from a binary representation.
func NewPublicKeyFromBytes(data []byte) *PublicKey {
	q, err := NewPointFromBytes(data)
	if err != nil {
		return nil
	}
	return &PublicKey{
		Q: q,
	}
}

// Bytes returns the binary representation of a public key.
func (pub *PublicKey) Bytes() []byte {
	return pub.Q.Bytes()
}

// Mult returns P = n*Q
func (pub *PublicKey) Mult(n *math.Int) *PublicKey {
	return &PublicKey{
		Q: pub.Q.Mult(n),
	}
}

//----------------------------------------------------------------------
// Private Key
//----------------------------------------------------------------------

// PrivateKey is a Ed25519 private key.
type PrivateKey struct {
	PublicKey

	Nonce []byte    // 32-byte nonce
	D     *math.Int // private scalar
}

// NewPrivateKeyFromSeed returns a private key for a given seed.
// If the seed has no matching length, no key is returned
func NewPrivateKeyFromSeed(seed []byte) *PrivateKey {
	// check seed size
	if len(seed) != 32 {
		return nil
	}
	// create private key
	key := &PrivateKey{}

	// compute hash from seed to derive 'd'
	md := sha512.Sum512(seed)
	d := reverse(md[:32])
	d[0] = (d[0] & 0x3f) | 0x40
	d[31] &= 0xf8

	// save nonce
	key.Nonce = make([]byte, 32)
	copy(key.Nonce, md[32:])

	// set private scalar and public point
	key.D = math.NewIntFromBytes(d)
	key.Q = c.MultBase(key.D)
	// return new private key instance
	return key
}

// NewPrivateKeyFromD returns a private key for a given factor.
// The 'nonce' value (generated from the seed in the "standard
// case") is now generated by hashing the key material itself.
func NewPrivateKeyFromD(d *math.Int) *PrivateKey {
	k := &PrivateKey{}
	k.D = d
	k.Q = c.MultBase(d)
	k.Nonce = make([]byte, 32)
	md := sha512.Sum512(d.Bytes())
	copy(k.Nonce, md[:32])
	return k
}

// Bytes returns the binary representation of a private key.
func (prv *PrivateKey) Bytes() []byte {
	buf := make([]byte, 64)
	copy(buf[:32], prv.Nonce)
	copy(buf[32:], prv.Q.Bytes())
	return buf
}

// Public returns the public key for a private key.
func (prv *PrivateKey) Public() *PublicKey {
	return &PublicKey{
		Q: prv.Q,
	}
}

// Mult returns a new private key with d' = n*d
func (prv *PrivateKey) Mult(n *math.Int) *PrivateKey {
	return NewPrivateKeyFromD(prv.D.Mul(n))
}

// NewKeypair creates a new Ed25519 key pair.
func NewKeypair() (*PublicKey, *PrivateKey) {
	seed := make([]byte, 32)
	_, _ = rand.Read(seed)
	prv := NewPrivateKeyFromSeed(seed)
	pub := prv.Public()
	return pub, prv
}
